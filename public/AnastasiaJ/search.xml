<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文本溢出显示的几中写法]]></title>
    <url>%2F2018%2F12%2F27%2F%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E7%9A%84%E5%87%A0%E4%B8%AD%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单行文本溢出（整行）效果： html1&lt;div class=&quot;test&quot;&gt;This is some long text that will not fit in the box&lt;/div&gt; css1234567div.test&#123; white-space:nowrap; width:12em; overflow:hidden; border:1px solid #000000; text-overflow:ellipsis;&#125; 非整行文本溢出效果： html12345678&lt;div class=&apos;table&apos;&gt; &lt;div class=&quot;test label&quot;&gt;姓名：&lt;/div&gt; &lt;div class=&quot;test value&quot;&gt;Anastasia&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;table&apos;&gt; &lt;div class=&quot;test label&quot;&gt;地址：&lt;/div&gt; &lt;div class=&quot;test value&quot;&gt;This is some long textThis is some long textThis is some long text&lt;/div&gt;&lt;/div&gt; css123456789101112131415161718div.table&#123; display:table; table-layout:fixed; border:solid 1px red; width:15em; &#125;div.test&#123; display:table-cell;&#125;div.label&#123; width:4em&#125;div.value&#123; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; &#125; 这里的几种设置和第一种是一样的，同样需要设置white-space、width、overflow，但由于用到了table的布局方式，table td的流动性，表格的宽度是跟随单元格内容多少自动计算尺寸，所以这里需要给table添加table-layout:fixed。 多行溢出（谷歌浏览器）效果 html1&lt;div class=&quot;test&quot; style=&quot;-webkit-box-orient:vertical;&quot;&gt;This is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long textThis is some long text&lt;/div&gt; css（注意css书写的顺序）123456789div&#123; text-overflow: ellipsis; overflow: hidden; margin: auto; width: 20em; //指定宽度 -webkit-box-orient: vertical; display: -webkit-box; -webkit-line-clamp: 3; //指定显示多少行&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>文本溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[antd-table中集成react-dnd]]></title>
    <url>%2F2018%2F12%2F21%2Fantd-table%E4%B8%AD%E9%9B%86%E6%88%90react-dnd%2F</url>
    <content type="text"><![CDATA[[ant-design官网表格排序例子(https://ant.design/components/table-cn/#components-table-demo-drag-sorting) 重写Table组件里的component代码如下：1234567891011121314151617181920212223242526272829class DragSortingTable extends React.Component &#123; state = &#123; data: [...], &#125; components = &#123; body: &#123; row: DragableBodyRow, &#125;, &#125; moveRow = (dragIndex, hoverIndex) =&gt; &#123; ... &#125; render() &#123; return ( &lt;Table columns=&#123;columns&#125; dataSource=&#123;this.state.data&#125; components=&#123;this.components&#125; onRow=&#123;(record, index) =&gt; (&#123; index, moveRow: this.moveRow, &#125;)&#125; /&gt; ); &#125;&#125; 其中主要代码是components={this.components}用来覆盖默认的 table 元素，拖动行则需要对row重写： 1234 body: &#123; row: DragableBodyRow, &#125;,&#125; DragableBodyRow为：12345678const DragableBodyRow = DropTarget(&apos;row&apos;, rowTarget, (connect, monitor) =&gt; (&#123; connectDropTarget: connect.dropTarget(),&#125;))( DragSource(&apos;row&apos;, rowSource, (connect, monitor) =&gt; (&#123; connectDragSource: connect.dragSource(), dragRow: monitor.getItem(), &#125;))(BodyRow)); DropTarget和DragSource 是高阶组件.12345678910111213141516171819class BodyRow extends React.Component &#123; render() &#123; const &#123; connectDragSource, connectDropTarget, ...restProps &#125; = this.props; ... return connectDragSource( connectDropTarget( &lt;tr &#123;...restProps&#125; /&gt; ) ); &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-dnd</tag>
        <tag>拖拽</tag>
        <tag>ant-design</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽组件：react-dnd]]></title>
    <url>%2F2018%2F12%2F19%2F%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6%EF%BC%9Areact-dnd%2F</url>
    <content type="text"><![CDATA[从昨天下午在弄一个关于拖拽的问题，实在有点心烦，先暂停下来，认真梳理一下关于这个组件的知识。 全文参考了silkshdow的文章， 原文地址 核心API DragSource 用于包装你需要拖动的组件，使组件能够被拖拽（make it draggable） DropTarget 用于包装接收拖拽元素的组件，使组件能够放置（dropped on it） DragDropContex 用于包装拖拽根组件，DragSource 和 DropTarget 都需要包裹在DragDropContex内 DragDropContextProvider 与 DragDropContex 类似，用 DragDropContextProvider 元素包裹拖拽根组件。 API参数介绍DragSource(type, spec, collect)DropTarget(type, spec, collect) type: 拖拽类型，必填 spec: 拖拽事件的方法对象，必填。 collect: 把拖拽过程中需要信息注入组件的 props，接收两个参数 connect and monitor，必填。 type 当 source组件的type 和 target组件的type 一致时，target组件可以接受source组件。 type的类型可以是 string，symbol，也可以是用一个函数来返回该组件的其他 props specspec定义特定方法的对象，如 source组件的spec 可以定义 拖动 相关的事件，target组件的spec 可以定义 放置 相关的事件，具体列表： 1. DragSource specObj beginDrag(props, monitor, component): 拖动开始时触发的事件，必须。返回跟props相关的对象。 endDrag(props, monitor, component): 拖动结束时触发的事件，可选。 canDrag(props, monitor): 当前是否可以拖拽的事件，可选。 isDragging(props, monitor): 拖拽时触发的事件，可选。12345678910111213141516171819// Box.jsxconst sourceSpec = &#123; beginDrag(props, monitor, component)&#123; // 返回需要注入的属性 return &#123; id: props.id &#125; &#125;, endDrag(props, monitor, component)&#123; // .. &#125;, canDrag(props, monitor)&#123; // .. &#125;, isDragging(props, monitor)&#123; // .. &#125;&#125;@DragSource(ItemTypes.BOX, sourceSpec, collect) 2. DropTarget specObj drop(props, monitor, component) 组件放下时触发的事件，可选。 hover(props, monitor, component) 组件在DropTarget上方时响应的事件，可选。 canDrop(props, monitor) 组件可以被放置时触发的事件，可选。 12345678910111213// Dustbin.jsxconst targetSpec = &#123;drop(props, monitor, component)&#123; // ..&#125;,hover(props, monitor, component)&#123; // ..&#125;,canDrop(props, monitor)&#123; // ..&#125;&#125;@DropTarget(ItemTypes.BOX, targetSpec, collect) 3. specObj 对象方法相关参数 props： 组件当前的props monitor：查询当前的拖拽状态，比如当前拖拽的item和它的type，当前拖拽的offsets，当前是否dropped。具体获取方法，参看collect 参数 monitor 部分 source组件 的 monitor 参数是 DragSourceMonitor 的实例 target组件 的 monitor 参数是 DropTargetMonitor 的实例 component：当前组件实例 4. collectcollect 是一个函数，默认有两个参数：connect 和 monitor。collect函数将返回一个对象，这个对象会注入到组件的 props 中，也就是说，我们可以通过 this.props 获取collect返回的所有属性。传递参数时需要，项目中很多地方会需要知道当前拖拽的相关数据，很有用 5. 参数 connect source组件 collect 中 connect是 DragSourceConnector的实例，它内置了两个方法：dragSource() 和 dragPreview()。dragSource()返回一个方法，将source组件传入这个方法，可以将 source DOM 和 React DnD backend 连接起来；dragPreview() 返回一个方法，你可以传入节点，作为拖拽预览时的角色。 target组件 collect 中 connect是 DropTargetConnector的实例，内置的方法dropTarget() 对应 dragSource()，返回可以将 drop target 和 React DnD backend 连接起来的方法。 12345678910111213141516171819202122232425262728293031323334// Box.jsx @DragSource(ItemTypes.BOX, sourceSpec,(connect)=&gt;(&#123; connectDragSource: connect.dragSource(), connectDragPreview: connect.dragPreview(), &#125;)) export default class Box &#123; render() &#123; const &#123; connectDragSource &#125; = this.props return connectDragSource( &lt;div&gt; &#123; /* ... */ &#125; &lt;/div&gt;, ) &#125; &#125; // Dustbin.jsx @DropTarget(ItemTypes.BOX, targetSpec, (connect)=&gt;&#123; connectDropTarget: connect.dropTarget(), &#125;) export default class Dustbin &#123; render() &#123; const &#123; connectDropTarget &#125; = this.props return connectDropTarget( &lt;div&gt; &#123; /* ... */ &#125; &lt;/div&gt;, ) &#125; &#125; 6. 参数 monitormonitor 用于查询当前的拖拽状态，其对应实例内置了很多方法。内置方法列表： 12345678910111213141516171819202122232425 // DragSourceMonitormonitor.canDrag() // 是否能被拖拽monitor.isDragging() // 是否正在拖拽monitor.getItemType() // 拖拽组件typemonitor.getItem() // 当前拖拽的itemmonitor.getDropResult() // 查询drop结果monitor.didDrop() // source是否已经drop在targetmonitor.getInitialClientOffset() // 拖拽组件初始拖拽时offsetmonitor.getInitialSourceClientOffset()monitor.getClientOffset() // 拖拽组件当前offsetmonitor.getDifferenceFromInitialOffset() // 当前拖拽offset和初始拖拽offset的差别monitor.getSourceClientOffset()// DropTargetMonitormonitor.canDrop() // 是否可被放置monitor.isOver(options) // source是否在target上方monitor.getItemType() // 拖拽组件typemonitor.getItem() // 当前拖拽的itemmonitor.getDropResult() // 查询drop结果monitor.didDrop() // source是否已经drop在targetmonitor.getInitialClientOffset() // 拖拽组件初始拖拽时offsetmonitor.getInitialSourceClientOffset()monitor.getClientOffset() // 拖拽组件当前offsetmonitor.getDifferenceFromInitialOffset() // 当前拖拽offset和初始拖拽offset的差别monitor.getSourceClientOffset() 最后以上是一个网友的总结，我实际上是需要在antd的table组件中使用的，react-dnd与antd-table组合又有些不同，将在下一篇文章中记录。 拖拽时候的样式重写 react-dnd-text-dragpreview 官网例子官方源码]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react-dnd</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试整理——一]]></title>
    <url>%2F2018%2F11%2F22%2F%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E4%B8%80%2F</url>
    <content type="text"><![CDATA[左右布局（左定宽，右边自适应宽度） 写法一(利用calc)： 1234567891011121314151617181920212223 //html &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt;//css .container&#123; width:100%; height:100%; font-size:0; &#125; .left&#123; background: orange; width:220px; height: 100%; display: inline-block; &#125; .content&#123; background: lightblue; height: 100%; width: calc(100% - 220px); display: inline-block; &#125; 利用css3 函数——calc， 注意：calc中的运算符前后要留白，否则不起作用 。这里同样可以使用 float:left。 注意这里使用的 inline-block 使用inline-block会存在间隙问题，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个。 取消换行可以解决间隙的问题（不推荐）； 设置 font-size:0;那么空白符也会变成0px； 写法二（浮动）： 123456789101112131415161718192021 //html &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt;//css .container&#123; width:100%; height:100%; &#125; .left&#123; background: orange; width:220px; height:100%; float: left; &#125; .content&#123; background: lightblue; margin-left: 220px; height:100%; &#125; 写法三（浮动和负边距）： 123456789101112131415161718192021222324252627282930 //html &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content-inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;//css .container&#123; width:100%; height:100%; &#125; .left&#123; background: orange; width:220px; height:100%; float: left; margin-right: -100%; &#125; .content&#123; width: 100%; float: left; height: 100%; &#125; .content-inner&#123; background: lightblue; margin-left: 220px; height:100%; &#125; 盒子模型从外到内依次：margin&gt;border&gt;padding&gt;content. box-sizing:content-box（默认）:width=padding+content;border-box:width=border+padding+content; box-sizing: content-box 是W3C盒子模型; box-sizing: border-box 是IE盒子模型 css画三角形width:0; height:0; border:solid 20px transparent; border-top-color: #000; 只要保证内容是空的，三角形的高就是边宽，只显示一边的颜色。 事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序（默认是冒泡）。 IE对应的方法attachEvent()和 detachEvent()。，attachEvent()的第一个参数是”onclick”，而非 DOM 的 addEventListener()方法中的”click”。 阻止冒泡的方法 12345&lt;div id=&quot;divOne&quot; onclick=&quot;alert(&apos;我是最外层&apos;);&quot;&gt; &lt;div id=&quot;divTwo&quot; onclick=&quot;alert(&apos;我是中间层！&apos;)&quot;&gt; &lt;a id=&quot;hr_three&quot; href=&quot;http://www.baidu.com&quot; onclick=&quot;alert(&apos;我是最里层！&apos;)&quot;&gt;点击我&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; event.stopPropagation(); 1234567&lt;script type=&quot;text/javascript&quot;&gt; $(function() &#123; $(&quot;#hr_three&quot;).click(function(event) &#123; event.stopPropagation(); &#125;); &#125;); &lt;script&gt; 再点击“点击我”，会弹出：我是最里层，然后链接到百度 return false; 12345678910 如果头部加入的是以下代码&lt;script type=&quot;text/javascript&quot;&gt;$(function() &#123; $(&quot;#hr_three&quot;).click(function(event) &#123; return false; &#125;);&#125;);&lt;script&gt; 再点击“点击我”，会弹出：我是最里层，但不会执行链接到百度页面 event.preventDefault();事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） 事件委托 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 使用事件委托，只需在DOM 树中尽量最高的层次上添加一个事件处理程序，如下面的例子所示。12345678910111213141516var list = document.getElementById(&quot;myLinks&quot;);EventUtil.addHandler(list, &quot;click&quot;, function(event)&#123;event = EventUtil.getEvent(event);var target = EventUtil.getTarget(event);switch(target.id)&#123;case &quot;doSomething&quot;: document.title = &quot;I changed the document&apos;s title&quot;; break;case &quot;goSomewhere&quot;: location.href = &quot;http://www.wrox.com&quot;; break;case &quot;sayHi&quot;: alert(&quot;hi&quot;); break;&#125;&#125;); 那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。 开始被问到这个词的时候，脑子里的第一反应居然是事件绑定。。。画个小圈圈让自己牢牢记住！ call,apply,bind 改变函数运行时this的指向。 具体区别和应用参考文章 call，apply，bind的用法与区别 use strict为什么用严格模式 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 如何调用针对单个脚本1234&lt;script&gt; &quot;use strict&quot;; console.log(&quot;这是严格模式。&quot;); &lt;/script&gt; 针对单个函数 1234&lt;script&gt; &quot;use strict&quot;; console.log(&quot;这是严格模式。&quot;); &lt;/script&gt; 严格模式下与普通模式下有什么区别全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 禁止this关键字指向全局对象 123456789function f()&#123; return !this; &#125; // 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false function f()&#123; &quot;use strict&quot;; return !this; &#125; // 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。12345function f()&#123; &quot;use strict&quot;; this.a = 1; &#125;; f();// 报错，this未定义 禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。12345678&quot;use strict&quot;; var x; delete x; // 语法错误 var o = Object.create(null, &#123;&apos;x&apos;: &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 对象不能有重名的属性正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 12345&quot;use strict&quot;; var o = &#123; p: 1, p: 2 &#125;; // 语法错误 函数不能有重名的参数正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。1234&quot;use strict&quot;; function f(a, a, b) &#123; // 语法错误 return ; &#125; setTimeout(0)if 里为否的情况对一个数组进行排序，奇数在前，偶数在后对 ES6 有使用过哪些双等（==）和三等（===）的区别]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>左右布局</tag>
        <tag>盒子模型</tag>
        <tag>css画三角形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack demo]]></title>
    <url>%2F2018%2F10%2F12%2Fwebpack%2F</url>
    <content type="text"><![CDATA[简单的webpack demo 配置文件 package.json{ &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;server&quot;: &quot;node server.js&quot;, &quot;build&quot;: &quot;webpack&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;express&quot;: &quot;^4.16.4&quot;, &quot;file-loader&quot;: &quot;^2.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;, &quot;style-loader&quot;: &quot;^0.23.1&quot;, &quot;webpack&quot;: &quot;^4.20.2&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot;, &quot;webpack-dev-middleware&quot;: &quot;^3.4.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.9&quot;, &quot;xml-loader&quot;: &quot;^1.2.1&quot; }, &quot;dependencies&quot;: { &quot;lodash&quot;: &quot;^4.17.11&quot; } } webpack 建议本地安装，这可以使我们在引入破坏式变更的依赖时，更容易分别升级项目。 本地安装webpack后，能够从node_modules/.bing/webpack 访问它的bin版本 从配置的依赖项来看，除了基本的webpack 及webpack-cli，还包括express、loader、plugin、middleware等，这些下面会进行说明。 webpack.config.jsconst path = require(&apos;path&apos;); const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;); const webpack = require(&apos;webpack&apos;); module.exports = { entry: { app: &apos;./src/index.js&apos; }, devtool: &apos;inline-source-map&apos;, devServer: { contentBase: &apos;./dist&apos;, hot: true }, module: { rules: [ { test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] } ] }, plugins: [ new CleanWebpackPlugin([&apos;dist&apos;]), new HtmlWebpackPlugin({ title: &apos;Output Management&apos; }), new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin() ], output: { filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;/&apos; } }; entry 项目入口单个 entry=’./src/index.js’； 多个 entry={ app:’./src/index.js’, main:’./src/main.js’} output 项目出口output: { filename: &apos;[name].bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;/&apos; } filename顾名思义，输出的文件的名字，多个入口的情况下，’[name].bundle.js’ 会将文件输出为’app.bundle.js’及’main.bundle.js’，根据起点名称生成bundle文件。 path 输出路径； publicPath：公共路径，会在服务器脚本用到，确保文件资源能够在 http://localhost:3000 下正确访问 loader 管理资源webpack 通过 loader 引入任何其他类型的文件。 /.css$/: style-loader、css-loader；//css /.(png|svg|jpg|gif)$/: file-loader；//图片 /.(woff|woff2|eot|ttf|otf)$/: file-loader；//字体 /.(csv|tsv)$/: csv-loader；//csv /.xml$/: xml-loader；//xml数据 import Data from &apos;./data.xml&apos;; function component() { console.log(Data); //import 这四种类型的数据(JSON, CSV, TSV, XML)中的任何一种，所导入的 Data 变量将包含可直接使用的已解析 JSON } 全局资源- |- /assets + |– /components + | |– /my-component + | | |– index.jsx + | | |– index.css + | | |– icon.svg + | | |– img.png 类似这样，将模块和资源组合在一起，无需依赖于含有全部资源的 /assets 目录，而是将资源与代码组合在一起，这样的结构会非常有用。 会使代码更具有可移植性，因为现有的统一放置的方式会造成所有资源紧密耦合在一起。 当无法用这种方式开发，或者有多个组件间资源共享的时候，仍然可以将这些资源存储在公共目录中，配合 alias 来使用他们更方便import导入。 alias写法：resolve:{ alias: { ASSET: path.join(src, &apos;assets&apos;), xyz$: path.resolve(__dirname, &apos;path/to/file.js&apos;) }, } import Test1 from &apos;xyz&apos;; // 精确匹配，所以 path/to/file.js 被解析和导入 import Test2 from &apos;xyz/file.js&apos;; // 非精确匹配，触发普通解析 在给定对象的键后的末尾添加 $，以表示精准匹配 pluginsHtmlWebpackPluginnpm install --save-dev html-webpack-plugin 该插件会根据我们的配置自动生成一个html入口文件，不用我们自己手动写。这样的好处就是，即使配置文件的入口点等名称改了，我们不用重新去修改index.html文件的内容。 生成的bundle文件会自动添加到html中。 清理/dist文件夹npm install clean-webpack-plugin --save-dev 每次webpack生成文件前建议清除 /dist 文件夹，避免过去生成的代码和最新的混合在一起。 开发使用 source map (devtool)用webpack打包，开发时需要追踪到具体错误和警告产生的位置，根据想要的效果不同需要做不同的配置。 开发环境适合使用：eval-source-map生产环境可省略 具体说明还可查看 官方配置 自动监测代码的变化一下三种工具能在代码发生变化时自动编译代码： webpack’s Watch Mode webpack-dev-server webpack-dev-middleware 观察模式直接在配置文件package.json 中添加脚本 &quot;watch&quot;: &quot;webpack --watch&quot; 缺点：需要手动刷新浏览器 webpack-dev-servernpm install --save-dev webpack-dev-server 在webpack.config.js中配置，告诉开发服务器在哪里查找文件 devServer: { contentBase: &apos;./dist&apos; } 同时添加一个 script 脚本，可以直接运行开发服务器(dev server)： &quot;start&quot;: &quot;webpack-dev-server --open&quot; webpack-dev-middleware 配合 express server`npm install --save-dev express webpack-dev-middleware` webpack.config.js output: { publicPath: &apos;/&apos; } server.js const express = require(&apos;express&apos;); const webpack = require(&apos;webpack&apos;); const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;); const app = express(); const config = require(&apos;./webpack.config.js&apos;); const compiler = webpack(config); // Tell express to use the webpack-dev-middleware and use the webpack.config.js // configuration file as a base. app.use(webpackDevMiddleware(compiler, { publicPath: config.output.publicPath })); // Serve the files on port 3000. app.listen(3000, function () { console.log(&apos;Example app listening on port 3000!\n&apos;); }); package.json &quot;scripts&quot;: { &quot;server&quot;: &quot;node server.js&quot;, } 热替换在项目已经运行的情况下，可以尝试模块热替换。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>模块打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的程序设计]]></title>
    <url>%2F2018%2F09%2F29%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[所有对象均继承自 Object 创建对象的几种方法1. new Object()var person = new Object(); person.name = &quot;Nicholas&quot;; person.age = 29; person.job = &quot;Software Engineer&quot;; person.sayName = function(){ alert(this.name); }; 2. 对象字面量var person = { name: &quot;Nicholas&quot;, age: 29, job: &quot;Software Engineer&quot;, sayName: function(){ alert(this.name); } }; 3. 工厂模式function createPerson(name, age, job){ var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function(){ alert(this.name); }; return o; } var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 4. 构造函数模式function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.sayName = function(){ alert(this.name); }; } var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 5. 原型模式 我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 function Person(){ } Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 29; Person.prototype.job = &quot;Software Engineer&quot;; Person.prototype.sayName = function(){ alert(this.name); }; var person1 = new Person(); person1.sayName(); //&quot;Nicholas&quot; var person2 = new Person(); person2.sayName(); //&quot;Nicholas&quot; alert(person1.sayName == person2.sayName); //true 理解原型对象(hasOwnProperty)无论什么时候，只要创建了一个新函数，就会为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。（实例中没有才会搜索原型对象） 使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中(只在给定属性存在于对象实例中时，才会返回 true)。 原型与 in 操作符(in)有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 更简单的原型语法function Person(){ } Person.prototype = { name : &quot;Nicholas&quot;, age : 29, job: &quot;Software Engineer&quot;, sayName : function () { alert(this.name); } }; 这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了。 原型的动态性在prototype 内添加属性、方法，不管是在实例化之前还是之后，实例化的对象都能够访问到。 但是整个原型对象重写除外。实例被创建时有一个指向原型的指针，一旦原型被重写，实例没办法指向新的原型。 function Person(){ } var friend = new Person(); Person.prototype = {//整个原型被重写 constructor: Person, name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, sayName : function () { alert(this.name); } }; friend.sayName(); //error 原生对象的原型 原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 原型对象的问题 它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值. 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，然而，对于包含引用类型值的属性来说，问题就比较突出了. function Person(){ } Person.prototype = { constructor: Person, name : &quot;Nicholas&quot;, age : 29, job : &quot;Software Engineer&quot;, friends : [&quot;Shelby&quot;, &quot;Court&quot;], sayName : function () { alert(this.name); } }; var person1 = new Person(); var person2 = new Person(); person1.friends.push(&quot;Van&quot;); alert(person1.friends); //&quot;Shelby,Court,Van&quot; alert(person2.friends); //&quot;Shelby,Court,Van&quot; alert(person1.friends === person2.friends); //true 6. 组合使用构造函数模式和原型模式比较 1、2两种方法，对于创建很多相同结构对象的时候，不会产生冗余代码；构造函数相对于工厂模式的优势在于能够使用 constructor 属性 及 instanceof 操作符去识别对象。instanceof比constructor更准确，在prototype被重写的情况下，constructor不能确定对象的类型。 alert(person1.constructor == Person); //true alert(person1 instanceof Object); //true alert(person1 instanceof Person); //true 未完，待续…内容太多了]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js生成UUID]]></title>
    <url>%2F2018%2F09%2F14%2Fjs%E7%94%9F%E6%88%90UUID%2F</url>
    <content type="text"><![CDATA[什么是UUID UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。如此一来，每个人都可以创建不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库创建时的名称重复问题。目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID），而其他重要的应用，则有Linux ext2/ext3文件系统、LUKS加密分区、GNOME、KDE、Mac OS X等等。另外我们也可以在e2fsprogs包中的UUID库找到实现。 JS生成// 生成uuid function generateUUID() { var d = new Date().getTime(); if (window.performance &amp;&amp; typeof window.performance.now === &quot;function&quot;) { d += performance.now(); //use high-precision timer if available } var uuid = &apos;xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx&apos;.replace(/[xy]/g, function (c) { var r = (d + Math.random() * 16) % 16 | 0; d = Math.floor(d / 16); return (c == &apos;x&apos; ? r : (r &amp; 0x3 | 0x8)).toString(16); }); return uuid; }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中return、break、continue的区别]]></title>
    <url>%2F2018%2F09%2F07%2Freturn%E3%80%81break%E3%80%81continue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[break是跳出一层循环，continue是结束一趟循环 ,return才是结束所有层循环! 如果有多层for循环,break会跳出当前这一层,去执行最外层循环(而不是退出所有层循环);而continue则结束当前次循环(继续)而去执行下次循环,但本层循环没有结束.(注意一层循环和一次循环的区别:一层循环包含若干(i)次循环) return return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。 break 只能在循环体内和switch语句体内使用break语句。 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环。 continue 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>return</tag>
        <tag>break</tag>
        <tag>continue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF.js]]></title>
    <url>%2F2018%2F09%2F07%2FPDF-js%2F</url>
    <content type="text"><![CDATA[PDF.js介绍PDF.js 是基于开放的 HTML5 及 JavaScript 技术实现的开源产品。简单说就是一个 PDF 解析器。 最初使用这个东西的原因是公司技术总监说要做一个打印模板设计器。本公司的产品有很多内容都是需要打印的，且每个打印的内容页面设计是不一样的，导致每次实现打印页面的时候就要单独写一个HTML页面，部分还涉及到小票的套打，很繁琐。因此，需要做一个打印设计器，方便每次打印页面的生成，具体我也不知道是怎么弄的。。。后台开发将设计好的内容以buffer的形式传给前端显示，前端这边需要做的就是将buffer内容用PDF显示出来。 下载官网地址 显示 buffer 内容 将viewer.js文件中的变量 DEFAULT_URL 删除 在viewer.html中重新定义DEFAULT_URL,我们在这里做buffer的转换，必须把buffer转换成Uint8Array类型，这样pdf.js才能直接解析。 1234567891011&lt;script&gt; let = &quot;&quot;;//注意，删除的变量在这里重新定义 let PDFData = window.sessionStorage.pdf; let rawLength = PDFData.length; //转换成pdf.js能直接解析的Uint8Array类型,见pdf.js-4068 let array = new Uint8Array(new ArrayBuffer(rawLength)); for(i = 0; i &lt; rawLength; i++) &#123; array[i] = PDFData.charCodeAt(i) &amp; 0xff; &#125; DEFAULT_URL = array;&lt;/script&gt; 这段代码中我将buffer保存在浏览器本地传过来的，因为是在react项目中使用，我没有想到更好的办法将react组件中产生的内容传递到HTML页面中。。。。 以上代码要放在&lt;script src=&quot;viewer.js&quot;&gt;&lt;/script&gt;前面。 至此，内容应该是可以显示了。 直接弹出打印预览窗口前面说过，公司产品有很多内容都是需要打印的，客户不会太愿意在打开PDF预览界面之后手动点击打印按钮去打印，然后弹出打印预览窗口，还要点击打印，从打印机打印出来，这对客户来说打印需要执行的操作付出的代价过大了，所以为了更好的客户体验，在PDF页面渲染完成后直接弹出打印预览界面。 PDF.js重写了浏览器本身的打印方法123//viewer.jsdocument.getElementById(&apos;print&apos;).addEventListener(&apos;click&apos;, SecondaryToolbar.printClick.bind(SecondaryToolbar)); RenderingStates 渲染状态viewer.js 中有RenderingStates来表示渲染的状态123456var RenderingStates = &#123; INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3&#125;; 错误： 首先想到在view.renderingState === RenderingStates.FINISHED的时候执行，即 12345678isViewFinished: function PDFRenderingQueue_isViewFinished(view) &#123; &lt;!-- 添加打印代码 --&gt; if(view.renderingState === RenderingStates.FINISHED &amp;&amp; sessionStorage.isPrint === &apos;true&apos;)&#123; document.getElementById(&apos;print&apos;).click() &#125; &lt;!-- 添加打印代码 end--&gt; return view.renderingState === RenderingStates.FINISHED; &#125; 然后在加载页面多的时候会有这样的提示 嗯==，然后我实在没有找到很合适的地方去调用打印的这个方法，最后在这里加上的 这样以后，‘PDF未完全加载已供打印’的提示没有的，打印页面也正常了。 注意sessionStorage.isPrint=false;这个控制语句要加上，不然即使点击了取消打印预览窗口，该窗口还是会不断弹出来。 如果有更好的方案，请不吝赐教，在下面留言，在下感激不尽。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>PDF.js</tag>
        <tag>JavaScript</tag>
        <tag>PDF解析器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之操作符]]></title>
    <url>%2F2018%2F09%2F06%2FJS%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[记录JS操作符一些重要并容易被忽略的一些用法 与（&amp;&amp;）操作 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值,即第一个操作数为false的时候。 例：123var found = true;var result = (found &amp;&amp; someUndefinedVariable); // 这里会发生错误alert(result); // 这一行不会执行 若开始found为false，则无论第二个操作符是什么，最后都会执行result为false 或（||）操作与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。 例：123var found = true;var result = (found || someUndefinedVariable); // 不会发生错误alert(result); // 会执行（&quot;true&quot;） 加只要有一个是字符串，另一个也默认转成字符串拼接 ‘5’+null= 5null 5+null= 5 5+undefined= NaN 1、有一个是字符串，那么另外一个也会转换为字符串进行拼接。假如一个是字符串，另外一个是null或者undefined，那么相加，null或者undefined就会调用String()方法，获得字符串“null”或者“undefined”，然后进行拼接。 2、假如一个数字加null或者undefined，那么还是把null或者undefined进行Number()转换之后再相加。 3、剩下的原则和其他的差不多，就不多说了。 乘在处理特殊值的情况下，乘法操作符遵循下列特殊的规则： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity； 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 减将结果转换成数值运算 如果操作数是对象，则调用对象valueOf方法，如果结果是NaN那么结果就是NaN。如果没有valueOf方法，那么调用toString()方法，并将得到的字符串转换为数值。 其他除了加法以外，几乎都是，只要有一个操作数是数值，另一个也默认使用Number()进行数字转换 除规则与乘类似，总之按照正常的运算逻辑来… 有逻辑不通的请一律参考乘的特殊规则 其中： 0/0==NaN 取余、求模 0%0==NaN 关系操作符统一返回true或者false `如果比较的两个数都是字符串，那么会比较字符串对应的字符串编码值。` 几个Number()转化取值： Number(null)==0 Number(undefined)==NaN 总结之前对运算的概念比较模糊，遇到正常的值还好，一旦遇到undefined、null这类特殊的预算就完全懵，其实对于有数字的运算，无外乎几种结果：数值、NaN、Infinity，加法才可能产生字符串的结果。 最后，本文写的过程中也学习了,这篇文章 js操作符类型转换大全（前端面试题之操作符）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT主题+githubPages个人博客搭建]]></title>
    <url>%2F2018%2F08%2F29%2Fhexo-nexT%E4%B8%BB%E9%A2%98-githubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装 node git hexo-cli npm install -g hexo-cli 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 结构说明 _config.yml 为站点配置文件 scaffolds 为模板文件夹 source 存放用户资源 themes 主题文件夹，里面也会有一个_config.yml，为主题配置文件 NexT主题安装 1git clone https://github.com/theme-next/hexo-theme-next themes/next 这样主题文件就拷贝到themes文件夹中 设置主题 站点配置文件： theme: next 站点文件配置官方配置文档 deploy 部署部分的设置1234deploy:type: gitbranch: 分支名字repo: https://github.com/github用户名/github用户名.github.io.git url配置If your site is put in a subdirectory, set url as ‘http://yoursite.com/child&#39; and root as ‘/child/‘ 12url: https://Anastasia.github.ioroot: /AnastasiaJ/ 本地运行 hexo s --debug 1&lt;div&gt;Syntax Highlighting&lt;/div&gt; 浏览器打开必须是 localhost:4000/你的root 发布到服务器：以上配置好后分别执行12hexo cleanhexo d -g 或者 hexo g -d 最好建一个分支，分支作为发布的博客内容，master作为构建代码，便于多台电脑发布博客 .md文件配置12345678title: hexo+nexT主题+githubPages个人博客搭建date: 2018-08-29 09:41:56categories: "博客搭建" #分类toc: true #是否显示文章目录tags: -nexT -hexo -githubPages 写作 新建文章 hexo new post title (post不定，可以是scaffolds中的任意一篇草稿) 插件 站点访问量“不蒜子” 评论系统1：Valine 评论系统2：必来力LiveRe 音乐：hexo-tag-aplayer 其他插件可参考NexT 使用文档 走过的坑仓库的名字仓库的名字的正确格式是github用户名.github.io hexo s 启动命令不识别需要安装 hexo-server 以上内容写的比较简单，主要是记录了一个主要的搭建过程，具体详细的部分都有官方文档可参考，这里不另外阐述。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
        <tag>githubPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+NEXT主题个性化配置]]></title>
    <url>%2F2018%2F08%2F27%2FHEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要说明当前博客中的音乐及其他主题个性化配置 左下角音乐使用插件hexo-tag-aplayer | aplayer npm install hexo-tag-aplayer –save （aplayer） 在themes/next/layout/_custom/header 中加入以下语句，具体的可参考官方文档设置&lt;div id=&quot;player1&quot; class=&quot;aplayer&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://pe5s1kztp.bkt.clouddn.com/css/APlayer.min.css&quot; /&gt; &lt;script src=&quot;http://pe5s1kztp.bkt.clouddn.com/js/APlayer.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; const apo = new APlayer({ container: document.getElementById(&apos;player1&apos;), fixed: true,//固定在左下角 autoplay: false, audio: [{ name: &apos;周杰伦&apos;, artist: &apos;水管的友情&apos;, url: &apos;http://pe5s1kztp.bkt.clouddn.com/music%E6%B0%B4%E7%AE%A1%E7%9A%84%E5%8F%8B%E6%83%85.flac&apos;, cover: &apos;http://pe5s1kztp.bkt.clouddn.com/images/employee-1118183_640.jpg&apos;, }] }); &lt;/script&gt; 其他个性化配置可参考二次元博客 :）]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
